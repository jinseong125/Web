JSX(JavaScript XML)란?
* XML/HTML 문법을 JavaScript 안에 직접 쓸 수 있게 해주는 문법 확장.
* 브라우저가 직접 읽는 건 아니고, Babel 같은 트랜스파일러가 React.createElement() 호출로 변환해 준다.

JSX를 사용하는이유
* 가독성: 컴포넌트의 구조를 HTML처럼 한눈에 보기 쉽고,
* 표현력: JavaScript 변수나 함수 호출 결과를 {}안에 바로 삽입가능.
* 안전성: 텍스트 노드나 속성 값에 자동으로 이스케이프 처리가 되어 XSS
          공격 위험이 줄어든다.
rendering
ReactDOM.createRoot(document.getElementById('...')).render(...);          

<div id="root1"></div>

<script type="text/babel">
  // ① type="text/babel":
  //    브라우저가 아닌 Babel(트랜스파일러)이 이 스크립트를 JSX → 순수 JS로 변환하도록 지시합니다.

  //----- JSX를 이용한 Element 만들기
  // ② JSX 문법으로 <h1> 요소를 생성하여 h1Element 변수에 담습니다.
  const h1Element = <h1>Hello World</h1>;

  // ④ .render(h1Element):
  //    앞서 만든 h1Element(JSX)를 실제 DOM에 그려 줍니다.
  ReactDOM.createRoot(document.getElementById('root1')).render(h1Element);
</script>

여러 태그를 단일태그로 생성하기 - <React.Fragment></React.Fragment>로 가능하지만,
<></>로 줄여서 사용 가능
예시 코드
div id="root2"></div>
<script type="text/babel">

 //----- 여러 태그를 단일 태그로 생성하기
 const divElement = <React.Fragment>
   <div>Hello World</div>
   <div>Nice to meet you</div>
  </React.Fragment>

  // <React.Fragment>의 축약버전
    const pElement = <>
    <p>Hello World</p>
    <p>Nice to meet you</p>
    </>

중괄호{}를 이용한 표현식/ 주석 작성하는 법.
1) // 태그 내부의 주석은 중괄호를 사용하지 않는다.(주로 시작 태그에 주석을 답니다.) 
2) {/*태그 외부의 주석은 중괄호를 사용해야 한다.*/}
3){
    // 슬래시 2개 주석 (single line comment)은 중괄호와 다른 줄에 작성해야한다.
  }  
셀프 클로징 태그란? (*반드시 뒤에 슬래시(/)를 추가해야함.)
JSX를 쓸 때는 “내용 없으면 무조건 <… />” 
내용이 있으면 <Tag>…</Tag>, 없으면 <Tag />로 작성 가능.

삼항 연산자: 조건 ? 참문장 : 거짓문장
JSX 안에 태그도 넣을 수 있고, 변수 할당도 가능
논리 연산자(&&, ||)와 용도는 비슷하지만, 둘 중 하나만 확실하게 렌더링할 땐 삼항이 더 직관적
너무 복잡해지면 if/else나 별도 함수로 빼서 가독성 유지하기.

객체 리터럴 형식으로 스타일 전달하기.
JSX에서 인라인 스타일을 객체 리터럴로 전달하는 법은
* style 속성에 중괄호 두번{{...}} 사용하기
- 첫 번째 중괄호{}: JSX에서 JS표현식 사용
- 두 번째 중괄호{}: JS 객체 리터럴

* 클래스형 컴포넌트 만들기: 컴포넌트 기능을 활용하기 위해서 React.component를 상속받도록 만든다.
<div id="root1"></div>
<script type="text/babel">

 class ClassComp extends React.Component {
  클래스형 컴포넌트 정의: React.Component를 상속받아 만듭니다.

  render() {
   render메소드: 이 컴포넌트가 화면에 그려줄 JSX를 반환하는 함수.

    return <h1>Hello Class Component</h1>
    JSX 반환: 태그안에 "Hello Class Component"라는 텍스트를 렌더링.
  }
  }
  //----- rendering: 컴포넌트는 태그 형식으로 렌더링합니다.
  ReactDOM.createRoot(document.getElementById('root1')).render(<ClassComp/>);
</script>

* 함수형 컴포넌트 만들기: 함수 선언식, 함수 표현식 모두 사용 가능.
const FunctionComp = () => {
  // props가 필요없으면 매개변수 빈 괄호만 사용가능

  return (
    // 컴포넌트가 화면에 렌더링할 JSX를 return 한다.
    <>
    <div>Hello Function Component</div>
    <div>Nice to meet you</div>
    </> //여러요소를 입력해서 사용할때는 Fragment(<></>를 사용)
  )
}
// rendering
ReactDOM.createRoot(document.getElementById('root2')).render(<FunctionComp/>);
</script>

defaultProps는 컴포넌트에 전달된 props가 없거나 undefined일 때 기본으로
사용할 값을 정의해주는 기능.

props.children은 컴포넌트의 안쪽에 들어온 콘텐츠를 꺼내서 렌더링해 주는 기능.
const GiftCard1 = (props) => {
  return (
    <h1>{props.children}</h1>
  )
}

const GiftCard2 = (props) => {
  const {children} = props;
  return (
    <h1>{children}</h1>
  )
}

const GiftCard3 = ({children}) => {
  return (
    <h1>{children}</h1>
  )
}

ReactDOM.createRoot(document.getElementById('root3')).render([
  <GiftCard1>3만원</GiftCard1>,
  <GiftCard2>5만원</GiftCard2>,
  <GiftCard3><em>10만원</em></GiftCard3>,
])

</script>
props drilling은 하위 컴포넌트에 값을 연속해서 전달하는 방식입니다.
                 좋은 방식이 아니므로 권장하지 않음.


